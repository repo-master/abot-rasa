version: '3.1'

intents:
# - change_aggregation:
#     use_entities:
#     - metric_type
#     - location
#     - aggregation
# - change_location:
#     use_entities:
#     - metric_type
#     - location
#     - aggregation
# - change_sensor:
#     use_entities:
#     - metric_type
#     - location
#     - aggregation
# - change_time_period
- query_metric_aggregate:
    use_entities:
    - metric_type
    - location
    - aggregation
- change_source
# - summarize_sensor_data:
#     use_entities:
#     - metric_type
- query_sensor_list
- query_location_list
- query_value_of_data_timerange
- query_value_of_data_location
- activate_sensor_name_form

entities:
- metric_type
- aggregation
- location
- sensor_name


slots:
  metric:
    type: text
    mappings:
    - type: from_entity
      entity: metric_type
  aggregation:
    type: list
    mappings:
    - type: from_entity
      entity: aggregation
  location:
    type: text
    mappings:
    - type: from_entity
      entity: location
  sensor_name:
    type: text
    mappings:
    - type: from_entity
      entity: sensor_name
  slot_json:
    type: any
    mappings:
    - type: custom

  # Timestamp range for grabbing data. ISO8601 strings of entered time,
  # a dict of {'body': '...', 'from': '...', 'to': '...'} for range.
  # If it fails, you get a list (all entity values)
  data_time_range:
    type: any
    mappings:
    - type: from_entity
      entity: time

  # When true, if asked to change any aggregation, it will load data again.
  # If false, will prompt
  data_auto_load_on_aggregation:
    type: bool
    initial_value: true
    mappings:
    - type: custom

forms:
  form_metric_data:
    required_slots:
    - metric
    - location
    
  form_sensor_name:
    required_slots:
    - sensor_name

actions:
- action_metric_aggregate
- action_metric_summarize
- action_fetch_report
- action_show_sensor_list
- action_show_location_list
- action_ask_data_value_timerange
- action_ask_data_value_location
- action_search_sensor_by_name

responses:
  # Uttered by form_metric_data automatically when an entity is missing.
  utter_ask_metric:
  - text: Which Sensor are you looking for?
  utter_ask_location:
  - text: Ok, which location where you are looking for this data
  utter_ask_data_time_range:
  - text: Please Specify time period
  utter_ask_aggregation:
  - text: What type of aggregation type should be done?
  utter_ask_sensor_name:
  - text: Which sensor are your looking this data for?
